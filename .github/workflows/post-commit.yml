# This workflow builds and runs unit tests on both Windows and Linux, as well as running
# WSL to test remote connection between OSes.

name: Post-Commit

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  # Allow this workflow to be triggered manually, with an optional parameter to enable remote debugging
  workflow_dispatch:
    inputs:
      tmate_enabled:
        type: boolean
        description: 'Run the build with tmate debugging enabled (https://github.com/marketplace/actions/debugging-with-tmate)'     
        required: false
        default: false

env:
  CARGO_TERM_COLOR: always

jobs:
  # This job builds and runs unit tests on both Windows and Linux (natively, no WSL).
  # No remote platforms are available for testing, so tests that require that are not run.
  native:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v3
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      # Skip tests that require a remote, as this isn't available in this environment.
      # The below "remote-platforms" job tests remote connection by using WSL.
      run: cargo test --verbose -- --skip "remote_tests::"

  # This job sets up a Windows runner with WSL, so that tests that require remote
  # platforms (e.g. a Linux to Windows sync) can be tested.
  remote-platforms:
    runs-on: windows-2019 # Trying using different version to fix rustc crash

    steps:
    - uses: actions/checkout@v3
    - uses: Vampire/setup-wsl@v1 # Note this sets up a WSL 1 (not WSL 2) environment, so network access is slightly different etc.
      with:
        # curl and ca-certificates: For installing rust
        # build-essential: so that a linker is available when running rustc
        # ssh for both client and server, needed for test environment
        additional-packages:
          curl ca-certificates
          build-essential
          ssh

    - name: Set up cargo on WSL
      shell: wsl-bash {0}
      run: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
      
    # It crashes in windows-latest servers!
    - name: Test if rustc crashes in wsl
      shell: wsl-bash {0}
      run: |
        source "$HOME/.cargo/env"
        sleep 3 # Make sure log output is visible up to here, before it crashes
        rustc --version
      
    # Can't seem to get the windows OpenSSH server installed, as we get an error when adding the optional package.
    # There is an sshd already installed as part of cygwin, but this means that when we log in we get a cygwin prompt, not a windows prompt
    # So instead we use chocolately to install OpenSSH.
    - name: Set up Windows SSH server
      shell: pwsh
      run: |
        choco install openssh --no-progress
        &"C:\Program Files\OpenSSH-Win64\install-sshd.ps1"

        # Add the new ssh installation to the PATH. Even though chocolately claims to do this based on its log messages,
        # it doesn't seem to actually work. Note that this will only take effect after this current "run" action,
        # but that's fine, as there is an existing SSH installation (in C:\Windows\System32\OpenSSH\) which will work for now.
        # We do need to make sure the newer ssh.exe is used for our actual tests though, as it fixes a bug that causes a hang:
        # https://github.com/PowerShell/Win32-OpenSSH/issues/856
        echo "C:\Program Files\OpenSSH-Win64" >> $env:GITHUB_PATH

        # Start the service so that it creates a default sshd_config file. We'll modify this later.
        Start-Service sshd
        # For debugging, start sshd instead with debug flag so we get logging:
        # Start-Job -WorkingDirectory . -ScriptBlock { & 'C:\Program Files\OpenSSH-Win64\sshd.exe' -ddd }
        # Then use Receive-Job X (where X is the ID reported by the Start-Job command) to get the job output while it runs in the background

        # Remove "Match Group administrators" from bottom of sshd_config so that it uses the normal authorized_keys location,
        # otherwise we get permission problems and can't use the below scripts to fix them.
        $content = Get-Content "C:\ProgramData\ssh\sshd_config"
        $content[0..($content.length-3)] | Out-File "C:\ProgramData\ssh\sshd_config"

        # Disable password authentication, so that if anything goes wrong (e.g. key not installed properly) then we don't hang the job at a password prompt
        echo "PasswordAuthentication no" >> "C:\ProgramData\ssh\sshd_config"

        # Restart sshd so it picks up the config file changes
        Restart-Service sshd

        # Create user key
        mkdir $env:USERPROFILE\.ssh
        ssh-keygen -f $env:USERPROFILE\.ssh\id_rsa -q -N '""'

        # Add user key to authorized_keys, so can login without password
        cp $env:USERPROFILE\.ssh\id_rsa.pub $env:USERPROFILE\.ssh\authorized_keys

        # Disable host key checking so we don't get the prompt
        echo "Host *" > $env:USERPROFILE\.ssh\config
        echo "  StrictHostKeyChecking no" >> $env:USERPROFILE\.ssh\config

        # Fix all the permissions
        &'C:\Program Files\OpenSSH-Win64\FixHostFilePermissions.ps1' -Confirm:$false
        &'C:\Program Files\OpenSSH-Win64\FixUserFilePermissions.ps1' -Confirm:$false

        # Confirm we can login without a password
        ssh localhost "ver && echo Windows to Windows SSH is working"

    - name: Check sssh version
      shell: pwsh
      run: |
        $env:PATH  -split ';'
        ssh --version
      

    - name: Set up WSL SSH server
      shell: wsl-bash {0}
      run: |
        # Disable password authentication, so that if anything goes wrong (e.g. key not installed properly) then we don't hang the job at a password prompt
        echo "PasswordAuthentication no" >> "/etc/ssh/sshd_config"

        # Make sshd listen only on localhost. By default it listens on all interfaces, but this means that both
        # it and the native Windows sshd will be both listening on all interfaces, which makes it impossible(?)
        # to distinguish which to connect to. For consistency with the way this behaves on WSL 2, tell the WSL
        # sshd to listen just on 127.0.0.1.
        echo "ListenAddress 127.0.0.1" >> "/etc/ssh/sshd_config"

        # Start sshd
        service ssh start

        # Create ssh key
        ssh-keygen -f ~/.ssh/id_rsa -q -N ""
       
        # Disable host key checking so we don't get the prompt
        echo "Host *" > ~/.ssh/config
        echo "  StrictHostKeyChecking no" >> ~/.ssh/config
        chmod 644 ~/.ssh/config

        # Add user key to authorized_keys, so can login without password
        cp ~/.ssh/id_rsa.pub ~/.ssh/authorized_keys

        # Confirm we can login without a password
        ssh 127.0.0.1 "uname -a && echo WSL to WSL SSH is working"

    - name: Set up Windows to WSL SSH
      shell: pwsh
      run: |
        wsl bash -c "cat /mnt/c/Users/runneradmin/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys"
        ssh root@127.0.0.1 "uname -a && echo Windows to WSL SSH is working"
      
    - name: Setup WSL to Windows SSH
      shell: wsl-bash {0}
      run: |
        cat ~/.ssh/id_rsa.pub >> /mnt/c/Users/runneradmin/.ssh/authorized_keys
        # Get the IP address to use to connect to Windows SSH. Now that we have both Windows and WSL SSH running, 
        # we need to use the IP address of a different interface than just localhost in order to get the right one
        WINDOWS_IP=$(hostname -I | cut -d ' ' -f1)
        ssh runneradmin@$WINDOWS_IP "ver && echo WSL to Windows SSH is working"

    # Beware that the tmate session runs inside cygwin, so some behaviour doesn't match native windows
    # Note that if this step happens before the "choco install", then we can't manually run choco inside tmate
    # because cygwin messes up the temp variables
    - name: Set up tmate session for debugging (only if enabled)
      if: ${{ github.event_name == 'workflow_dispatch' && inputs.tmate_enabled }}
      uses: mxschmitt/action-tmate@v3
    
    - name: Run remote tests on Windows
      shell: pwsh
      env:
        RUST_LOG: trace #TODO: remove this once figure out the issue why these tests are hanging. Seems to be related to scp - perhaps it's trying to read input from something?
      # Only run tests that require a remote, as the other tests are covered by the "native" jobs above.
      # The logic in remote_tests.rs should automatically detect the WSL instance and connect to that
      # These tests can be resource-intensive (building rjrssync on remote hosts), so run one at a time,
      # and print the test output as they run so can see the progress
      run: cargo test --verbose -- "remote_tests::" --test-threads 1 --nocapture

    - name: Run remote tests on WSL
      # Only run tests that require a remote, as the other tests are covered by the "native" jobs above.
      # The logic in remote_tests.rs should automatically detect the Windows host and connect to that
      # These tests can be resource-intensive (building rjrssync on remote hosts), so run one at a time,
      # and print the test output as they run so can see the progress
      shell: wsl-bash {0}
      env:
        RUST_LOG: trace #TODO: and this
      run: cargo test --verbose -- "remote_tests::" --test-threads 1 --nocapture

